# التقرير التطويري الشامل لمشروع "Ask Seba" (نسخة محسنة)

**إعداد:** Manus AI
**تاريخ:** 08 يناير 2026

## 1. ملخص الوضع الحالي: واجهة ممتازة، منطق وهمي

بعد التحليل الشامل للمشروع، تقرير Cursor الجنائي (FORENSIC AUDIT REPORT)، والآراء المرفقة، تم التوصل إلى استنتاج واضح وموحد: مشروعك "Ask Seba" هو **نموذج أولي لواجهة المستخدم (UI Prototype) عالي الجودة**، لكنه يفتقر إلى أي منطق خلفي (Backend) أو قاعدة بيانات حقيقية. [1]

- **نقاط القوة:** تصميم جذاب، تجربة مستخدم (UX) سلسة خلال خطوات الاختبار (Quiz)، بنية كود أمامية (Frontend) نظيفة باستخدام Next.js و TypeScript.
- **نقاط الضعف الجوهرية:**
    - **قاعدة بيانات وهمية:** يعتمد التطبيق بالكامل على 19 عطرًا فقط مدخلة يدويًا في ملف `src/lib/data/perfumes.ts`.
    - **خوارزمية مطابقة زائفة:** نسبة المطابقة (e.g., 92% Match) هي مجرد رقم ثابت في البيانات، وليست نتيجة لأي معادلة حسابية حقيقية. [1]
    - **تخزين مؤقت:** تفضيلات المستخدم تُحفظ في `sessionStorage`، مما يعني أنها تُفقد بمجرد إغلاق تبويب المتصفح.
    - **واجهة مستخدم غير مكتملة (Dead UI):** بعض الأزرار والوظائف (مثل زر "أضف للتحليل" وفلاتر الحساسية المتقدمة) موجودة شكليًا فقط ولا تؤدي أي وظيفة. [1]

> **الخلاصة:** التقرير الجنائي من Cursor دقيق 100%. التطبيق الحالي ينجح في إظهار *كيف سيبدو* المنتج النهائي، لكنه لا يعمل كما هو متوقع من الداخل. هذا هو الأساس الممتاز الذي سنبني عليه الآن بشكل صحيح.

## 2. الإجابة الحاسمة: هل تضيف 1000 عطر الآن؟

**الإجابة القصيرة والقاطعة: لا.**

إضافة 1000 عطر الآن إلى ملف `JSON` ثابت سيكون خطأ فادحًا. يجب أولًا بناء البنية التحتية للبيانات (Data Layer)، ثم ملؤها بالبيانات الضخمة. بناء الميزات على بنية وهمية سيؤدي حتمًا إلى عمل مزدوج ومشاكل أداء وتعقيدات مستقبلية.

## 3. الخطة التنفيذية الشاملة: من النموذج الأولي إلى منتج حقيقي

هذه هي خطة العمل الموحدة التي تجمع كل الخطوات اللازمة بالترتيب الصحيح، مع البرومبتات الدقيقة والمفصلة لكل مرحلة.

### المرحلة الأولى: إصلاح النموذج الأولي وتفعيله (Sprint 1: يومان)

**الهدف:** تحويل الواجهة من مجرد شكل إلى كيان وظيفي متكامل يتفاعل مع البيانات المحدودة الحالية (19 عطرًا) بشكل صحيح.

#### الخطوة 1.1: تفعيل الأزرار الميتة (Dead UI)

**البرومبت المقترح لـ Cursor:**

```prompt
**TASK: Activate PerfumeCard 'Add to Analysis' Button**

1.  **Analyze `src/components/ui/PerfumeCard.tsx` and `src/contexts/QuizContext.tsx`.**
2.  **Implement the `onClick` handler for the 'أضف للتحليل' button inside `PerfumeCard.tsx`.**
3.  **The button's function should be to add the perfume's `id` to the `step1_liked` array in the `QuizContext`.**
4.  **Ensure the `QuizContext` and `sessionStorage` are updated correctly upon clicking the button.**
5.  **Make the button visually responsive on click (e.g., change text to 'تمت الإضافة' or show a checkmark) to provide user feedback.**
```

#### الخطوة 1.2: تفعيل منطق فلترة الحساسية بالكامل

**البرومبت المقترح لـ Cursor:**

```prompt
**TASK: Implement Full Allergy Filtering Logic**

1.  **Analyze the data structure in `src/contexts/QuizContext.tsx` for `step3_allergy` which includes `symptoms`, `families`, and `ingredients`.**
2.  **Analyze the filtering logic in `src/app/results/page.tsx`.**
3.  **Current logic only filters by `ingredients`. Expand this logic to also filter based on `symptoms` and `families` selected by the user.**
4.  **To do this, you will need to expand the `perfumes.ts` data model to include `families` and `ingredients` for each perfume. For now, add sample data for the existing 19 perfumes.**
5.  **The filtering logic should exclude any perfume that matches the user's selected allergy criteria (symptoms, families, or ingredients).**
```

### المرحلة الثانية: بناء أساس قاعدة البيانات (Sprint 2: 3 أيام)

**الهدف:** إنشاء بنية قاعدة البيانات الحقيقية ونقل البيانات الأولية إليها، واستبدال مصدر البيانات الوهمي بمصدر حقيقي.

#### الخطوة 2.1: إعداد قاعدة البيانات وتصميم Schema

**البرومبت المقترح لـ Cursor:**

```prompt
**TASK: Initialize Database with Prisma and PostgreSQL**

1.  **Install Prisma client and initialize it in the project: `npm install prisma` and `npx prisma init --datasource-provider postgresql`.**
2.  **Define the database schema in `prisma/schema.prisma`. Create two models: `Perfume` and `UserPreference`.**
3.  **The `Perfume` model must include:**
    - `id` (String, @id)
    - `name` (String)
    - `brand` (String)
    - `image` (String)
    - `description` (String)
    - `scent_pyramid` (Json, for top/heart/base notes)
    - `ingredients` (String[])
    - `families` (String[])
4.  **The `UserPreference` model must include:**
    - `id` (String, @id)
    - `sessionId` (String, @unique)
    - `likedPerfumes` (Json)
    - `dislikedPerfumes` (Json)
    - `allergyProfile` (Json)
5.  **Generate the Prisma client: `npx prisma generate`.**
```

#### الخطوة 2.2: نقل البيانات واستبدال المصدر

**البرومبت المقترح لـ Cursor:**

```prompt
**TASK: Seed Database and Switch Data Source**

1.  **Create a seed script at `prisma/seed.ts`.**
2.  **In the seed script, import the 19 perfumes from `src/lib/data/perfumes.ts` and transform them to fit the new `Perfume` schema. Add sample data for the new fields (`scent_pyramid`, `ingredients`, `families`).**
3.  **Use `prisma.perfume.create` to populate the database with this seed data.**
4.  **Modify the search API endpoint at `src/app/api/perfumes/search/route.ts` to fetch data from the Prisma client instead of the static `perfumes.ts` file.**
5.  **Ensure the entire application now uses this API endpoint for fetching perfume data, completely removing the dependency on the static file.**
```

### المرحلة الثالثة: تطبيق خوارزمية المطابقة الحقيقية (Sprint 3: 3-4 أيام)

**الهدف:** استبدال نسبة المطابقة الثابتة بخوارزمية حقيقية وديناميكية تعتمد على تفضيلات المستخدم.

#### 3.1. فلسفة الخوارزمية: من الثابت إلى الديناميكي

الخوارزمية هي نظام مرجح يوازن بين **ذوق المستخدم (Taste)** و**عامل الأمان (Safety)** بالمعادلة التالية:

`Match Score = (Taste Score * 0.7) + (Safety Score * 0.3)`

- **Taste Score (70%):** يقيس مدى توافق العطر مع العطور التي يحبها المستخدم، باستخدام معامل Jaccard للتشابه بين العائلات العطرية.
- **Safety Score (30%):** يمثل مدى أمان العطر للمستخدم. تكون النتيجة إما 100 (آمن تمامًا) أو 0 (غير آمن) إذا وُجد مكون واحد مسبب للحساسية.

#### 3.3. مثال عملي: حساب درجة المطابقة

لنفترض أن لدينا مستخدمًا وملف تعريف العطور التالي:

**ملف تعريف المستخدم:**
- **عطور أعجبته (`likedPerfumes`):**
    - عطر (أ): `families: ['Woody', 'Aromatic']`
    - عطر (ب): `families: ['Woody', 'Spicy']`
- **حساسية من (`allergyProfile`):** `ingredients: ['linalool']`

**الحمض النووي العطري للمستخدم (User's Scent DNA):**
- مجموعة فريدة من العائلات المفضلة: `{'Woody', 'Aromatic', 'Spicy'}`

--- 

الآن، سنقوم بتقييم عطرين مختلفين لتوضيح الفكرة:

| الخاصية | العطر (س) - مرشح جيد | العطر (ص) - مرشح غير آمن |
| :--- | :--- | :--- |
| **العائلات** | `['Woody', 'Citrus']` | `['Woody', 'Aromatic']` |
| **المكونات** | `['limonene', 'citral']` | `['linalool', 'geraniol']` |
| **درجة الأمان** | **100** (لا يحتوي على linalool) | **0** (يحتوي على linalool) |
| **درجة الذوق** | **25** (تشابه Jaccard: 1/4) | **67** (تشابه Jaccard: 2/3) |
| **النتيجة النهائية** | `(25*0.7)+(100*0.3) = 47.5%` | `(67*0.7)+(0*0.3) = 46.9%` |
| **التوصية** | عرض كنتيجة مقبولة | **استبعاد** أو عرض بتحذير خطر |

هذا المثال يوضح كيف توازن الخوارزمية بين الذوق والأمان لتقديم توصيات أكثر دقة ومسؤولية.

#### 3.4. البرومبت النهائي لتنفيذ الخوارزمية في Cursor

هذا هو البرومبت الشامل الذي يقوم ببناء الخوارزمية وربطها بالتطبيق. انسخه والصقه في Cursor (Cmd+K).

```prompt
**TASK: Implement Dynamic Matching Algorithm (Phase 3)**

**CONTEXT:** The application currently uses a fake, static `matchPercentage`. We need to replace it with a real, dynamic matching algorithm based on user preferences (Taste & Safety).

**OBJECTIVE:** Create a server-side matching engine that calculates a personalized score for each perfume.

**STEP 1: Create the Core Logic File (`src/lib/matching.ts`)**

Create a new file `src/lib/matching.ts` and implement the following functions:

```typescript
// src/lib/matching.ts

// Type definitions based on prisma/schema.prisma
interface Perfume {
  id: string;
  families: string[];
  ingredients: string[];
}

interface UserPreference {
  likedPerfumes: { families: string[] }[];
  allergyProfile: { ingredients: string[] };
}

/**
 * Calculates the Jaccard index between two sets.
 */
function jaccardSimilarity(setA: Set<string>, setB: Set<string>): number {
  const intersection = new Set([...setA].filter(x => setB.has(x)));
  const union = new Set([...setA, ...setB]);
  if (union.size === 0) return 0;
  return intersection.size / union.size;
}

/**
 * Calculates the Taste Score based on shared scent families.
 */
function calculateTasteScore(perfume: Perfume, userScentDNA: Set<string>): number {
  const perfumeFamilies = new Set(perfume.families);
  const score = jaccardSimilarity(perfumeFamilies, userScentDNA);
  return Math.round(score * 100);
}

/**
 * Calculates the Safety Score based on user's allergies.
 */
function calculateSafetyScore(perfume: Perfume, userAllergies: Set<string>): number {
  const perfumeIngredients = new Set(perfume.ingredients);
  const hasAllergen = [...userAllergies].some(allergen => perfumeIngredients.has(allergen));
  return hasAllergen ? 0 : 100;
}

/**
 * Calculates the final weighted match score.
 */
export function calculateFinalMatchScore(tasteScore: number, safetyScore: number): number {
  const TASTE_WEIGHT = 0.7;
  const SAFETY_WEIGHT = 0.3;
  const finalScore = (tasteScore * TASTE_WEIGHT) + (safetyScore * SAFETY_WEIGHT);
  return Math.round(finalScore);
}

/**
 * The main function to calculate the match score for a single perfume.
 */
export function calculateMatchForPerfume(perfume: Perfume, userPreference: UserPreference): { finalScore: number; tasteScore: number; safetyScore: number } {
    const userScentDNA = new Set(userPreference.likedPerfumes.flatMap(p => p.families));
    const userAllergies = new Set(userPreference.allergyProfile.ingredients);

    const tasteScore = calculateTasteScore(perfume, userScentDNA);
    const safetyScore = calculateSafetyScore(perfume, userAllergies);
    const finalScore = calculateFinalMatchScore(tasteScore, safetyScore);

    return { finalScore, tasteScore, safetyScore };
}
```

**STEP 2: Create the API Endpoint (`src/app/api/match/route.ts`)**

Create a new API route that will process all perfumes and return a scored and sorted list.

```typescript
// src/app/api/match/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { calculateMatchForPerfume } from '@/lib/matching';

const prisma = new PrismaClient();

export async function POST(request: Request) {
  try {
    const { sessionId } = await request.json();

    if (!sessionId) {
      return NextResponse.json({ error: 'Session ID is required' }, { status: 400 });
    }

    // 1. Fetch all perfumes and user preferences in parallel
    const [allPerfumes, userPreference] = await Promise.all([
      prisma.perfume.findMany(),
      prisma.userPreference.findUnique({
        where: { sessionId },
        include: {
            likedPerfumes: { select: { families: true } },
            allergyProfile: { select: { ingredients: true } }
        }
      }),
    ]);

    if (!userPreference) {
      return NextResponse.json(allPerfumes.map(p => ({ ...p, finalScore: 30, tasteScore: 0, safetyScore: 100 })));
    }

    // 2. Calculate score for each perfume
    const scoredPerfumes = allPerfumes.map(perfume => {
      const { finalScore, tasteScore, safetyScore } = calculateMatchForPerfume(perfume, userPreference as any);
      return { ...perfume, finalScore, tasteScore, safetyScore };
    });

    // 3. Sort perfumes by the final score in descending order
    const sortedPerfumes = scoredPerfumes.sort((a, b) => b.finalScore - a.finalScore);

    return NextResponse.json(sortedPerfumes);

  } catch (error) {
    console.error('Matching API Error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

**STEP 3: Update the Results Page (`src/app/results/page.tsx`)**

Refactor the results page to fetch data from the new `/api/match` endpoint.

1.  Use `useEffect` to make a `POST` request to `/api/match` with the user's `sessionId`.
2.  Store the returned list of scored perfumes in the component's state.
3.  Render the `PerfumeCard` components using this new state.
4.  Pass the `finalScore` to the `matchPercentage` prop of the `PerfumeCard`.
5.  Remove all old client-side filtering and sorting logic, as the backend now handles it.

**Verify that the results page displays the dynamically scored and sorted perfumes.**
```

## 4. خارطة الطريق المستقبلية

بعد إكمال هذه المراحل الثلاث، سيكون لديك تطبيق يعمل بشكل حقيقي مع بنية تحتية قوية. عندها فقط، يمكنك البدء في الخطوات التالية بثقة:

- **استيراد 1000+ عطر:** الآن يمكنك استيراد البيانات الضخمة إلى قاعدة بياناتك الحقيقية.
- **حسابات المستخدمين:** الانتقال من `sessionId` إلى نظام تسجيل دخول كامل مع `NextAuth` لحفظ تفضيلات المستخدمين بشكل دائم.
- **تحسين الخوارزمية:** جعل خوارزمية المطابقة أكثر تعقيدًا وذكاءً (مثل تحليل الهرم العطري بالكامل).
- **نشر التطبيق (Deployment):** نشر التطبيق على منصة مثل Vercel.

باتباع هذه الخطة الموحدة، ستضمن أنك تبني تطبيقك على أساس متين، مما يوفر عليك الكثير من الوقت والجهد على المدى الطويل ويمنع كسر التطبيق.

---
**المراجع:**
[1] FORENSIC_AUDIT_REPORT.md (الملف المرفق)
